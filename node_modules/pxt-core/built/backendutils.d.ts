/// <reference path="../localtypings/pxtarget.d.ts" />
/// <reference path="../localtypings/dompurify.d.ts" />
declare namespace pxt {
    interface TelemetryEventOptions {
        interactiveConsent: boolean;
    }
    /**
     * Track an event.
     */
    let tickEvent: (id: string, data?: Map<string | number>, opts?: TelemetryEventOptions) => void;
}
declare namespace pxt {
    let appTarget: TargetBundle;
    let appTargetVariant: string;
    let hwVariant: string;
    let hwName: string;
}
declare namespace pxt {
    interface Logger {
        info(...args: any[]): void;
        log(...args: any[]): void;
        debug(...args: any[]): void;
        error(...args: any[]): void;
        warn(...args: any[]): void;
        setLogLevel(level: LogLevel): void;
        getLogLevel(): LogLevel;
    }
    enum LogLevel {
        Debug = 0,
        Info = 1,
        Log = 1,
        Warning = 2,
        Error = 3
    }
    class ConsoleLogger implements Logger {
        protected logLevel: LogLevel;
        constructor();
        setLogLevel(level: LogLevel): void;
        getLogLevel(): LogLevel;
        info(...args: any[]): void;
        log(...args: any[]): void;
        debug(...args: any[]): void;
        error(...args: any[]): void;
        warn(...args: any[]): void;
        protected shouldLog(level: LogLevel): boolean;
    }
    function info(...args: any[]): void;
    function log(...args: any[]): void;
    function debug(...args: any[]): void;
    function error(...args: any[]): void;
    function warn(...args: any[]): void;
    function setLogger(impl: Logger): void;
    function setLogLevel(level: LogLevel): void;
}
declare namespace ts.pxtc {
    let __dummy: number;
}
import pxtc = ts.pxtc;
declare namespace ts.pxtc.Util {
    function assert(cond: boolean, msg?: string): void;
    function flatClone<T extends Object>(obj: T): T;
    function clone<T>(v: T): T;
    function htmlEscape(_input: string): string;
    function htmlUnescape(_input: string): string;
    function jsStringQuote(s: string): string;
    function jsStringLiteral(s: string): string;
    function initials(username: string): string;
    function enableLiveLocalizationUpdates(): void;
    function liveLocalizationEnabled(): boolean;
    /**
     * Returns the current user language, prepended by "live-" if in live mode
     */
    function localeInfo(): string;
    /**
     * Returns current user language iSO-code. Default is `en`.
     */
    function userLanguage(): string;
    function normalizeLanguageCode(code: string): string[];
    function setUserLanguage(localizeLang: string): void;
    function isUserLanguageRtl(): boolean;
    const TRANSLATION_LOCALE = "pxt";
    function isTranslationMode(): boolean;
    function _localize(s: string): string;
    function getLocalizedStrings(): pxt.Map<string>;
    function setLocalizedStrings(strs: pxt.Map<string>): void;
    function translationsCache(): pxt.Map<pxt.Map<string>>;
    function fmt_va(f: string, args: any[]): string;
    function fmt(f: string, ...args: any[]): string;
    function dumpLocStats(): void;
    function lf_va(format: string, args: any[]): string;
    function lf(format: string, ...args: any[]): string;
    /**
     * Similar to lf but the string do not get extracted into the loc file.
     */
    function rlf(format: string, ...args: any[]): string;
    function lookup<T>(m: pxt.Map<T>, key: string): T;
    function isoTime(time: number): string;
    function userError(msg: string): never;
    function deq(a: any, b: any): string;
    function deepEqual(a: any, b: any): boolean;
}
declare const lf: typeof pxtc.Util.lf;
declare namespace pxt.docs {
    type MarkedRenderFunction = (src: string, options?: any) => string;
    interface MarkedRenderer {
        options?: any;
        parser: {
            parse: (tokens: any[], loose?: boolean) => string;
            parseInline: (tokens: any[]) => string;
        };
        code?: (token: any) => string;
        link?: (token: any) => string;
        image?: (token: any) => string;
        listitem?: (token: any) => string;
        heading?: (token: any) => string;
    }
    interface MarkedModule extends MarkedRenderFunction {
        Renderer: {
            new (): MarkedRenderer;
        };
        lexer: (src: string, options?: any) => any[];
        setOptions: (options: any) => void;
        parseInline?: (src: string, options?: any) => string;
    }
    export function htmlQuote(s: string): string;
    export function html2Quote(s: string): string;
    export interface BreadcrumbEntry {
        name: string;
        href: string;
    }
    export let requireMarked: () => MarkedModule | undefined;
    export let requireDOMSanitizer: () => typeof DOMPurify.sanitize;
    export interface RenderData {
        html: string;
        theme: AppTheme;
        params: Map<string>;
        filepath?: string;
        versionPath?: string;
        ghEditURLs?: string[];
        finish?: () => string;
        boxes?: Map<string>;
        macros?: Map<string>;
        settings?: Map<string>;
        TOC?: TOCMenuEntry[];
    }
    export function prepTemplate(d: RenderData): void;
    export interface RenderOptions {
        template: string;
        markdown: string;
        theme?: AppTheme;
        pubinfo?: Map<string>;
        filepath?: string;
        versionPath?: string;
        locale?: Map<string>;
        ghEditURLs?: string[];
        repo?: {
            name: string;
            fullName: string;
            tag?: string;
        };
        throwOnError?: boolean;
        TOC?: TOCMenuEntry[];
    }
    export function setupRenderer(renderer: MarkedRenderer, context?: {
        versionPath?: string;
    }): void;
    export function renderConditionalMacros(template: string, pubinfo: Map<string>): string;
    export function renderMarkdown(opts: RenderOptions): string;
    export function embedUrl(rootUrl: string, tag: string, id: string, height?: number): string;
    export function runUrl(url: string, padding: string, id: string): string;
    export function codeEmbedUrl(rootUrl: string, id: string, height?: number): string;
    export function translate(html: string, locale: Map<string>): {
        text: string;
        missing: Map<string>;
    };
    export function buildTOC(summaryMD: string): pxt.TOCMenuEntry[];
    export function visitTOC(toc: TOCMenuEntry[], fn: (e: TOCMenuEntry) => void): void;
    export function augmentDocs(baseMd: string, childMd: string): string;
    export {};
}
