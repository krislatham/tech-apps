/// <reference path="pxtlib.d.ts" />
/// <reference path="../localtypings/pxtarget.d.ts" />
/// <reference path="../localtypings/pxtpackage.d.ts" />
declare namespace pxt {
    interface SimpleDriverCallbacks {
        cacheGet: (key: string) => Promise<string>;
        cacheSet: (key: string, val: string) => Promise<void>;
        httpRequestAsync?: (options: Util.HttpRequestOptions) => Promise<Util.HttpResponse>;
        pkgOverrideAsync?: (id: string) => Promise<Map<string>>;
    }
    class SimpleHost implements pxt.Host {
        packageFiles: pxt.Map<string>;
        constructor(packageFiles: pxt.Map<string>);
        resolve(module: pxt.Package, filename: string): string;
        readFile(module: pxt.Package, filename: string): string;
        writeFile(module: pxt.Package, filename: string, contents: string): void;
        getHexInfoAsync(extInfo: pxtc.ExtensionInfo): Promise<pxtc.HexInfo>;
        cacheStoreAsync(id: string, val: string): Promise<void>;
        cacheGetAsync(id: string): Promise<string>;
        downloadPackageAsync(pkg: pxt.Package): Promise<void>;
        resolveVersionAsync(pkg: pxt.Package): Promise<string>;
    }
    function prepPythonOptions(opts: pxtc.CompileOptions): void;
    interface CompileResultWithErrors extends pxtc.CompileResult {
        errors?: string;
    }
    interface SimpleCompileOptions {
        native?: boolean;
    }
    function simpleInstallPackagesAsync(files: pxt.Map<string>): Promise<void>;
    function simpleGetCompileOptionsAsync(files: pxt.Map<string>, simpleOptions: SimpleCompileOptions): Promise<pxtc.CompileOptions>;
    function simpleCompileAsync(files: pxt.Map<string>, optionsOrNative?: SimpleCompileOptions | boolean): Promise<CompileResultWithErrors>;
    function patchTS(version: string, opts: pxtc.CompileOptions): void;
    function patchPY(version: string, opts: pxtc.CompileOptions): void;
    function setupSimpleCompile(cfg?: SimpleDriverCallbacks): void;
}
declare namespace pxt {
    function simshim(prog: ts.Program, pathParse: any): pxt.Map<string>;
}
declare namespace ts.pxtc {
    /**
     * Traverses the AST and injects information about function calls into the expression
     * nodes. The decompiler consumes this information later
     *
     * @param program The TypeScript Program representing the code to compile
     * @param entryPoint The name of the source file to annotate the AST of
     * @param compileTarget The compilation of the target
     */
    function annotate(program: Program, entryPoint: string, compileTarget: CompileTarget): void;
}
declare namespace ts.pxtc {
    interface BitSizeInfo {
        size: number;
        needsSignExt?: boolean;
        immLimit: number;
    }
    function asmStringLiteral(s: string): string;
    abstract class AssemblerSnippets {
        nop(): string;
        reg_gets_imm(reg: string, imm: number): string;
        proc_setup(numlocals: number, main?: boolean): string;
        push_fixed(reg: string[]): string;
        push_local(reg: string): string;
        push_locals(n: number): string;
        pop_fixed(reg: string[]): string;
        pop_locals(n: number): string;
        proc_return(): string;
        debugger_stmt(lbl: string): string;
        debugger_bkpt(lbl: string): string;
        debugger_proc(lbl: string): string;
        unconditional_branch(lbl: string): string;
        beq(lbl: string): string;
        bne(lbl: string): string;
        cmp(reg1: string, reg: string): string;
        cmp_zero(reg1: string): string;
        arithmetic(): string;
        load_reg_src_off(reg: string, src: string, off: string, word?: boolean, store?: boolean, inf?: BitSizeInfo): string;
        rt_call(name: string, r0: string, r1: string): string;
        call_lbl(lbl: string, saveStack?: boolean): string;
        call_reg(reg: string): string;
        helper_prologue(): string;
        helper_epilogue(): string;
        pop_clean(pops: boolean[]): string;
        load_ptr_full(lbl: string, reg: string): string;
        emit_int(v: number, reg: string): string;
        obj_header(vt: string): string;
        string_literal(lbl: string, strLit: string): string;
        hex_literal(lbl: string, data: string): string;
    }
    function utf8AsmStringLiteral(strLit: string): {
        vt: string;
        asm: string;
    };
    function hexLiteralAsm(data: string, suff?: string): string;
    function numBytes(n: number): number;
    class ProctoAssembler {
        private t;
        private bin;
        private resText;
        private exprStack;
        private calls;
        private proc;
        private baseStackSize;
        private labelledHelpers;
        constructor(t: AssemblerSnippets, bin: Binary, proc: ir.Procedure);
        emitHelpers(): void;
        private write;
        private redirectOutput;
        private stackSize;
        private stackAlignmentNeeded;
        getAssembly(): string;
        private work;
        private mkLbl;
        private dumpStack;
        private terminate;
        private validateJmpStack;
        private emitJmp;
        private clearStack;
        private emitExprInto;
        private bitSizeInfo;
        private emitExpr;
        private emitFieldAccess;
        private writeFailBranch;
        private emitClassCall;
        private helperObject;
        private emitBindHelper;
        private ifaceCallCore;
        private emitIfaceCall;
        private checkSubtype;
        private loadVTable;
        private emitInstanceOf;
        private emitSharedDef;
        private clearArgs;
        private builtInClassNo;
        private emitBeginTry;
        private emitRtCall;
        private alignedCall;
        private emitLabelledHelper;
        private emitHelper;
        private pushToExprStack;
        private pushArg;
        private loadFromExprStack;
        private pushDummy;
        private alignExprStack;
        private emitFieldMethods;
        private emitArrayMethod;
        private emitArrayMethods;
        private emitLambdaTrampoline;
        private emitProcCall;
        private lambdaCall;
        private emitStore;
        private cellref;
        private emitLambdaWrapper;
        private emitCallRaw;
    }
}
declare namespace ts.pxtc {
    function isBuiltinSimOp(name: string): boolean;
    function shimToJs(shimName: string): string;
    function jsEmit(bin: Binary, cres: CompileResult): void;
}
declare namespace ts.pxtc {
    const thumbCmpMap: pxt.Map<string>;
    class ThumbSnippets extends AssemblerSnippets {
        stackAligned(): boolean;
        pushLR(): "push {lr}" | "push {lr, r5}  ; r5 for align";
        popPC(): "pop {pc}" | "pop {pc, r5}  ; r5 for align";
        nop(): string;
        mov(trg: string, dst: string): string;
        helper_ret(): string;
        reg_gets_imm(reg: string, imm: number): string;
        push_fixed(regs: string[]): string;
        pop_fixed(regs: string[]): string;
        proc_setup(numlocals: number, main?: boolean): string;
        proc_return(): string;
        debugger_stmt(lbl: string): string;
        debugger_bkpt(lbl: string): string;
        debugger_proc(lbl: string): string;
        push_local(reg: string): string;
        push_locals(n: number): string;
        pop_locals(n: number): string;
        unconditional_branch(lbl: string): string;
        beq(lbl: string): string;
        bne(lbl: string): string;
        cmp(reg1: string, reg2: string): string;
        cmp_zero(reg1: string): string;
        load_reg_src_off(reg: string, src: string, off: string, word?: boolean, store?: boolean, inf?: BitSizeInfo): string;
        rt_call(name: string, r0: string, r1: string): string;
        alignedCall(lbl: string, stackAlign: number): string;
        call_lbl(lbl: string, saveStack?: boolean, stackAlign?: number): string;
        call_reg(reg: string): string;
        helper_prologue(): string;
        helper_epilogue(): string;
        load_ptr_full(lbl: string, reg: string): string;
        load_vtable(trg: string, src: string): string;
        lambda_init(): string;
        saveThreadStack(): string;
        restoreThreadStack(): "" | "movs r7, #0\n    str r7, [r6, #4]\n";
        callCPPPush(lbl: string): string;
        callCPP(lbl: string, stackAlign?: number): string;
        inline_decr(idx: number): string;
        arithmetic(): string;
        emit_int(v: number, reg: string): string;
    }
}
declare namespace ts.pxtc {
    function vmEmit(bin: Binary, opts: CompileOptions, cres: CompileResult): void;
}
declare namespace ts.pxtc.decompiler {
    export enum DecompileParamKeys {
        DecompileLiterals = "decompileLiterals",
        TaggedTemplate = "taggedTemplate",
        DecompileIndirectFixedInstances = "decompileIndirectFixedInstances",
        DecompileArgumentAsString = "decompileArgumentAsString"
    }
    export interface CommentInfo {
        kind: CommentKind;
        hasTrailingNewline: boolean;
        followedByEmptyLine: boolean;
        isTrailingComment: boolean;
        start: number;
        end: number;
        owner?: Node;
        ownerStatement?: StatementNode;
    }
    export enum CommentKind {
        SingleLine = 0,
        MultiLine = 1
    }
    export interface MultiLineComment extends CommentInfo {
        kind: CommentKind.MultiLine;
        lines: string[];
    }
    export interface SingleLineComment extends CommentInfo {
        kind: CommentKind.SingleLine;
        text: string;
    }
    export type Comment = MultiLineComment | SingleLineComment;
    export const DECOMPILER_ERROR = 9267;
    interface BlocklyNode {
        kind: string;
    }
    interface TextNode {
        kind: "text";
        value: string;
    }
    interface FieldNode extends BlocklyNode {
        kind: "field";
        name: string;
        value: string | number;
    }
    interface ValueNode extends BlocklyNode {
        kind: "value";
        name: string;
        value: OutputNode;
        shadowType?: string;
        shadowMutation?: pxt.Map<string>;
        emitShadowOnly?: boolean;
    }
    interface MutationChild {
        attributes: pxt.Map<string>;
        nodeName: string;
    }
    interface BlockNode extends BlocklyNode {
        type: string;
        inputs?: ValueNode[];
        fields?: FieldNode[];
        mutation?: pxt.Map<string>;
        mutationChildren?: MutationChild[];
    }
    interface ExpressionNode extends BlockNode {
        kind: "expr";
        handlers?: Handler[];
        isShadow?: boolean;
        id?: string;
    }
    interface StatementNode extends BlockNode {
        kind: "statement";
        handlers?: Handler[];
        next?: StatementNode;
        prev?: StatementNode;
        comment?: Comment[];
        id?: string;
        data?: string;
    }
    interface Handler {
        name: string;
        statement: StatementNode;
    }
    type OutputNode = ExpressionNode | TextNode;
    export interface RenameLocation {
        name: string;
        diff: number;
        span: ts.TextSpan;
    }
    export class RenameMap {
        private renames;
        constructor(renames: RenameLocation[]);
        getRenamesInSpan(start: number, end: number): RenameLocation[];
        getRenameForPosition(position: number): RenameLocation;
    }
    export type RenameMapOpts = {
        declarations: "variables" | "all";
        takenNames: NamesSet;
    };
    export type NamesSet = pxt.Map<boolean | {}>;
    /**
     * Uses the language service to ensure that there are no duplicate variable
     * names in the given file. All variables in Blockly are global, so this is
     * necessary to prevent local variables from colliding.
     */
    export function buildRenameMap(p: Program, s: SourceFile, { declarations, takenNames }?: RenameMapOpts): [RenameMap, NamesSet];
    export function getNewName(name: string, takenNames: NamesSet, recordNewName?: boolean): string;
    export interface DecompileBlocksOptions {
        snippetMode?: boolean;
        alwaysEmitOnStart?: boolean;
        errorOnGreyBlocks?: boolean;
        allowedArgumentTypes?: string[];
        generateSourceMap?: boolean;
        includeGreyBlockMessages?: boolean;
    }
    export function decompileToBlocks(blocksInfo: pxtc.BlocksInfo, file: ts.SourceFile, options: DecompileBlocksOptions, renameMap?: RenameMap): pxtc.CompileResult;
    export function getLeadingComments(node: Node, file: ts.SourceFile, commentRanges?: ts.CommentRange[]): Comment[];
    export function getTrailingComments(node: Node, file: ts.SourceFile): Comment[];
    export function getCommentsForStatement(commented: Node, commentMap: Comment[]): Comment[];
    export function buildCommentMap(file: SourceFile): Comment[];
    export {};
}
declare namespace ts.pxtc.service {
    /**
     * Produces a markdown string for the symbol that is suitable for display in Monaco
     */
    function displayStringForSymbol(sym: SymbolInfo, python: boolean, apiInfo: ApisInfo): string;
    function displayStringForKeyword(keyword: string, python: boolean): string;
}
declare namespace ts.pxtc.thumb {
    class ThumbProcessor extends pxtc.assembler.AbstractProcessor {
        constructor();
        toFnPtr(v: number, baseOff: number, lbl: string): number;
        wordSize(): number;
        is32bit(i: assembler.Instruction): boolean;
        postProcessAbsAddress(f: assembler.File, v: number): number;
        emit32(v0: number, v: number, actual: string): pxtc.assembler.EmitResult;
        expandLdlit(f: assembler.File): void;
        getAddressFromLabel(f: assembler.File, i: assembler.Instruction, s: string, wordAligned?: boolean): number;
        isPop(opcode: number): boolean;
        isPush(opcode: number): boolean;
        isAddSP(opcode: number): boolean;
        isSubSP(opcode: number): boolean;
        peephole(ln: pxtc.assembler.Line, lnNext: pxtc.assembler.Line, lnNext2: pxtc.assembler.Line): void;
        registerNo(actual: string): number;
        testAssembler(): void;
    }
}
declare namespace ts.pxtc.ir {
    enum EK {
        None = 0,
        NumberLiteral = 1,
        PointerLiteral = 2,
        RuntimeCall = 3,
        ProcCall = 4,
        SharedRef = 5,
        SharedDef = 6,
        FieldAccess = 7,
        Store = 8,
        CellRef = 9,
        Sequence = 10,
        JmpValue = 11,
        Nop = 12,
        InstanceOf = 13
    }
    class Node {
        private _id;
        isExpr(): this is Expr;
        isStmt(): this is Stmt;
        getId(): number;
    }
    interface ConvInfo {
        argIdx: number;
        method: string;
        returnsRef?: boolean;
        refTag?: pxt.BuiltInType;
        refTagNullable?: boolean;
    }
    interface MaskInfo {
        refMask: number;
        conversions?: ConvInfo[];
    }
    class Expr extends Node {
        exprKind: EK;
        args: Expr[];
        data: any;
        jsInfo: {};
        prevTotalUses: number;
        totalUses: number;
        currUses: number;
        irCurrUses: number;
        callingConvention: CallingConvention;
        mask: MaskInfo;
        isStringLiteral: boolean;
        constructor(exprKind: EK, args: Expr[], data: any);
        static clone(e: Expr): Expr;
        reset(): void;
        ptrlabel(): Stmt;
        hexlit(): any;
        isExpr(): boolean;
        isPure(): boolean;
        isLiteral(): boolean;
        isStateless(): boolean;
        sharingInfo(): string;
        toString(): string;
        canUpdateCells(): boolean;
    }
    enum SK {
        None = 0,
        Expr = 1,
        Label = 2,
        Jmp = 3,
        StackEmpty = 4,
        Breakpoint = 5,
        Comment = 6
    }
    enum JmpMode {
        Always = 1,
        IfZero = 2,
        IfNotZero = 3
    }
    const lblNumUsesJmpNext = -101;
    class Stmt extends Node {
        stmtKind: SK;
        expr: Expr;
        lblName: string;
        lbl: Stmt;
        lblNumUses: number;
        lblStackSize: number;
        jmpMode: JmpMode;
        lblId: number;
        breakpointInfo: Breakpoint;
        stmtNo: number;
        findIdx: number;
        terminateExpr: Expr;
        constructor(stmtKind: SK, expr: Expr);
        isStmt(): boolean;
        toString(): string;
    }
    class Cell {
        index: number;
        def: Declaration;
        info: VariableAddInfo;
        isarg: boolean;
        iscap: boolean;
        _isLocal: boolean;
        _isGlobal: boolean;
        _debugType: string;
        isUserVariable: boolean;
        bitSize: BitSize;
        repl: Expr;
        replUses: number;
        constructor(index: number, def: Declaration, info: VariableAddInfo);
        getName(): string;
        getDebugInfo(): CellInfo;
        toString(): string;
        uniqueName(): string;
        isLocal(): boolean;
        isGlobal(): boolean;
        loadCore(): Expr;
        load(): Expr;
        isByRefLocal(): boolean;
        storeDirect(src: Expr): Expr;
        storeByRef(src: Expr): Expr;
        get isTemporary(): boolean;
    }
    class UnnamedCell extends Cell {
        index: number;
        owningProc: Procedure;
        private static unnamedCellCounter;
        private uid;
        constructor(index: number, owningProc: Procedure);
        getName(): string;
        uniqueName(): string;
        isByRefLocal(): boolean;
        get isTemporary(): boolean;
    }
    interface ProcId {
        proc?: Procedure;
        callLocationIndex?: number;
        virtualIndex?: number;
        ifaceIndex?: number;
        classInfo?: ClassInfo;
        isSet?: boolean;
        isThis?: boolean;
        noArgs?: boolean;
    }
    class Procedure extends Node {
        numArgs: number;
        info: FunctionAddInfo;
        seqNo: number;
        isRoot: boolean;
        locals: Cell[];
        captured: Cell[];
        args: Cell[];
        parent: Procedure;
        debugInfo: ProcDebugInfo;
        fillDebugInfo: (th: assembler.File) => void;
        classInfo: ClassInfo;
        perfCounterName: string;
        perfCounterNo: number;
        body: Stmt[];
        lblNo: number;
        action: ts.FunctionLikeDeclaration;
        inlineBody: ir.Expr;
        cachedJS: string;
        usingCtx: PxtNode;
        reset(): void;
        isGetter(): boolean;
        vtLabel(): string;
        label(): string;
        toString(): string;
        emit(stmt: Stmt): void;
        emitExpr(expr: Expr): void;
        mkLabel(name: string): Stmt;
        emitLbl(lbl: Stmt): void;
        emitLblDirect(lblName: string): void;
        getFullName(): string;
        getName(): string;
        mkLocal(def: Declaration, info: VariableAddInfo): Cell;
        mkLocalUnnamed(): UnnamedCell;
        localIndex(l: Declaration, noargs?: boolean): Cell;
        stackEmpty(): void;
        emitJmpZ(trg: string | Stmt, expr: Expr): void;
        emitJmp(trg: string | Stmt, expr?: Expr, mode?: JmpMode, terminate?: Expr): void;
        inlineSelf(args: ir.Expr[]): Expr;
        resolve(): void;
    }
    function iterExpr(e: Expr, f: (v: Expr) => void): void;
    function stmt(kind: SK, expr: Expr): Stmt;
    function comment(msg: string): Stmt;
    function op(kind: EK, args: Expr[], data?: any): Expr;
    function numlit(v: number | boolean): Expr;
    function shared(expr: Expr): Expr;
    function ptrlit(lbl: string, jsInfo: string): Expr;
    function rtcall(name: string, args: Expr[], mask?: number): Expr;
    function rtcallMask(name: string, mask: number, callingConv: CallingConvention, args: Expr[]): Expr;
    function flattenArgs(args: ir.Expr[], reorder?: boolean, keepcomplex?: boolean): {
        precomp: Expr[];
        flattened: Expr[];
    };
}
declare namespace ts {
    interface Node {
        pxt: pxtc.PxtNode;
    }
}
declare namespace ts.pxtc {
    const enum PxtNodeFlags {
        None = 0,
        IsRootFunction = 1,
        IsBogusFunction = 2,
        IsGlobalIdentifier = 4,
        IsUsed = 8,
        InPxtModules = 16,
        FromPreviousCompile = 32,
        IsOverridden = 64
    }
    type EmitAction = (bin: Binary) => void;
    class PxtNode {
        wave: number;
        id: number;
        flags: PxtNodeFlags;
        typeCache: Type;
        symbolCache: Symbol;
        declCache: Declaration;
        commentAttrs: CommentAttrs;
        fullName: string;
        constantFolded: {
            val: any;
        };
        functionInfo: FunctionAddInfo;
        variableInfo: VariableAddInfo;
        classInfo: ClassInfo;
        proc: ir.Procedure;
        cell: ir.Cell;
        usedNodes: pxt.Map<Declaration>;
        usedActions: EmitAction[];
        callInfo: CallInfo;
        exprInfo: BinaryExpressionInfo;
        valueOverride: ir.Expr;
        refresh(): void;
        resetEmit(): void;
        resetTSC(): void;
        resetAll(): void;
        constructor(wave: number, id: number);
    }
    const taggedUndefined = 0;
    const taggedNull: number;
    const taggedFalse: number;
    const taggedNaN: number;
    const taggedTrue: number;
    const thumbArithmeticInstr: pxt.Map<boolean>;
    const numberArithmeticInstr: pxt.Map<boolean>;
    const SK: typeof SyntaxKind;
    const numReservedGlobals = 1;
    interface FieldWithAddInfo extends NamedDeclaration {
    }
    type EmittableAsCall = FunctionLikeDeclaration | SignatureDeclaration | ObjectLiteralElementLike | PropertySignature | ModuleDeclaration | ParameterDeclaration | PropertyDeclaration;
    function isInPxtModules(node: Node): boolean;
    function pxtInfo(n: Node): PxtNode;
    function getNodeId(n: Node): number;
    function stringKind(n: Node): any;
    function isStackMachine(): boolean;
    function needsNumberConversions(): boolean;
    function isThumb(): boolean;
    function sizeOfBitSize(b: BitSize): 1 | 4 | 2;
    function isBitSizeSigned(b: BitSize): boolean;
    function setCellProps(l: ir.Cell): void;
    function isStatic(node: Declaration): boolean;
    function isReadOnly(node: Declaration): boolean;
    function getExplicitDefault(attrs: CommentAttrs, name: string): string;
    function isObjectType(t: Type): t is ObjectType;
    interface CallInfo {
        decl: TypedDecl;
        qName: string;
        args: Expression[];
        isExpression: boolean;
        isAutoCreate?: boolean;
    }
    interface ITableEntry {
        name: string;
        idx: number;
        info: number;
        proc: ir.Procedure;
        setProc?: ir.Procedure;
    }
    class ClassInfo {
        id: string;
        decl: ClassDeclaration;
        derivedClasses?: ClassInfo[];
        classNo?: number;
        lastSubtypeNo?: number;
        baseClassInfo: ClassInfo;
        allfields: FieldWithAddInfo[];
        methods: pxt.Map<FunctionLikeDeclaration[]>;
        attrs: CommentAttrs;
        vtable?: ir.Procedure[];
        itable?: ITableEntry[];
        ctor?: ir.Procedure;
        toStringMethod?: ir.Procedure;
        constructor(id: string, decl: ClassDeclaration);
        reset(): void;
        get isUsed(): boolean;
        allMethods(): FunctionLikeDeclaration[];
        usedMethods(): FunctionLikeDeclaration[];
    }
    interface BinaryExpressionInfo {
        leftType: string;
        rightType: string;
    }
    let target: CompileTarget;
    let compileOptions: CompileOptions;
    function getNodeFullName(checker: TypeChecker, node: Node): string;
    function getComments(node: Node): string;
    function parseCommentsOnSymbol(symbol: Symbol): CommentAttrs;
    function parseComments(node: Node): CommentAttrs;
    function getName(node: Node & {
        name?: any;
    }): string;
    function checkType(t: Type): Type;
    function taggedSpecial(v: any): number;
    function getDeclName(node: Declaration): string;
    function getFunctionLabel(node: FunctionLikeDeclaration): string;
    interface FieldAccessInfo {
        idx: number;
        name: string;
        isRef: boolean;
        shimName: string;
        classInfo: ClassInfo;
        needsCheck: boolean;
    }
    type VarOrParam = VariableDeclaration | ParameterDeclaration | PropertyDeclaration | BindingElement;
    type TypedDecl = Declaration & {
        type?: TypeNode;
    };
    interface VariableAddInfo {
        captured?: boolean;
        written?: boolean;
        functionsToDefine?: FunctionDeclaration[];
    }
    class FunctionAddInfo {
        decl: EmittableAsCall;
        capturedVars: VarOrParam[];
        location?: ir.Cell;
        thisParameter?: ParameterDeclaration;
        virtualParent?: FunctionAddInfo;
        virtualIndex?: number;
        parentClassInfo?: ClassInfo;
        usedBeforeDecl?: boolean;
        usedAsValue?: boolean;
        usedAsIface?: boolean;
        alreadyEmitted?: boolean;
        constructor(decl: EmittableAsCall);
        get isUsed(): boolean;
    }
    function compileBinary(program: Program, opts: CompileOptions, res: CompileResult, entryPoint: string): EmitResult;
    function isStringType(t: Type): boolean;
    class Binary {
        procs: ir.Procedure[];
        globals: ir.Cell[];
        globalsWords: number;
        nonPtrGlobals: number;
        finalPass: boolean;
        target: CompileTarget;
        writeFile: (fn: string, cont: string) => void;
        trace: boolean;
        breakpoints: boolean;
        name: string;
        usedClassInfos: ClassInfo[];
        checksumBlock: number[];
        numStmts: number;
        commSize: number;
        packedSource: string;
        itEntries: number;
        itFullEntries: number;
        numMethods: number;
        numVirtMethods: number;
        usedChars: Uint32Array;
        explicitlyUsedIfaceMembers: pxt.Map<boolean>;
        ifaceMemberMap: pxt.Map<number>;
        ifaceMembers: string[];
        strings: pxt.Map<string>;
        hexlits: pxt.Map<string>;
        doubles: pxt.Map<string>;
        otherLiterals: string[];
        codeHelpers: pxt.Map<string>;
        lblNo: number;
        reset(): void;
        getTitle(): string;
        addProc(proc: ir.Procedure): void;
        recordHelper(usingCtx: PxtNode, id: string, gen: (bin: Binary) => string): void;
        recordAction<T>(usingCtx: PxtNode, f: (bin: Binary) => T): void;
        private emitLabelled;
        emitDouble(v: number): string;
        emitString(s: string): string;
        emitHexLiteral(s: string): string;
        setPerfCounters(systemPerfCounters: string[]): string[];
    }
    function isCtorField(p: ParameterDeclaration): boolean;
}
declare namespace ts.pxtc {
    interface CompileResult {
        ast?: Program;
    }
    function getTsCompilerOptions(opts: CompileOptions): CompilerOptions;
    function nodeLocationInfo(node: ts.Node): LocationInfo;
    function patchUpDiagnostics(diags: ReadonlyArray<Diagnostic>, ignoreFileResolutionErorrs?: boolean): KsDiagnostic[];
    function py2tsIfNecessary(opts: CompileOptions): transpile.TranspileResult | undefined;
    function storeGeneratedFiles(opts: CompileOptions, res: CompileResult): void;
    function runConversionsAndStoreResults(opts: CompileOptions, res?: CompileResult): CompileResult;
    function timesToMs(res: CompileResult): void;
    function isPxtModulesFilename(filename: string): boolean;
    interface CompilerHooks {
        init?(opts: CompileOptions, service?: LanguageService): void;
        preBinary?(program: Program, opts: CompileOptions, res: CompileResult): void;
        postBinary?(program: Program, opts: CompileOptions, res: CompileResult): void;
    }
    let compilerHooks: CompilerHooks;
    function compile(opts: CompileOptions, service?: LanguageService): CompileResult;
    function decompile(program: Program, opts: CompileOptions, fileName: string, includeGreyBlockMessages?: boolean): CompileResult;
    function decompileSnippets(program: Program, opts: CompileOptions, includeGreyBlockMessages?: boolean): string[];
    function getTSProgram(opts: CompileOptions, old?: ts.Program): Program;
}
declare namespace pxt.elf {
    interface Info {
        template: Uint8Array;
        imageMemStart: number;
        imageFileStart: number;
        phOffset: number;
    }
    function parse(buf: Uint8Array): Info;
    function patch(info: Info, program: Uint8Array): Uint8Array;
}
declare namespace pxt.esp {
    interface Segment {
        addr: number;
        isMapped: boolean;
        isDROM: boolean;
        data: Uint8Array;
    }
    interface Image {
        header: Uint8Array;
        chipName: string;
        segments: Segment[];
    }
    function toBuffer(image: Image, digest?: boolean): Uint8Array;
    function parseBuffer(buf: Uint8Array): Image;
    function parseB64(lines: string[]): Image;
    function cloneStruct(img: Image): Image;
}
declare namespace ts.pxtc {
    function toStr(v: any): string;
    function format(input: string, pos: number): {
        formatted: string;
        pos: number;
    };
}
declare namespace ts.pxtc {
    namespace hexfile {
        let asmTotalSource: string;
        function getCommBase(): number;
        function getStartAddress(): number;
        function getTopFlashAddress(): number;
        function setupInlineAssembly(opts: CompileOptions): void;
        function parseHexBytes(bytes: string): number[];
        function parseHexRecord(bytes: string): {
            len: number;
            addr: number;
            type: number;
            data: number[];
            checksum: number;
        };
        function flashCodeAlign(opts: CompileTarget): number;
        function setupFor(opts: CompileTarget, extInfo: ExtensionInfo, cres: CompileResult): void;
        function validateShim(funname: string, shimName: string, attrs: CommentAttrs, hasRet: boolean, argIsNumber: boolean[]): void;
        function lookupFunc(name: string): FuncInfo;
        function lookupFunctionAddr(name: string): number;
        function hexTemplateHash(): string;
        function hexPrelude(): string;
        function hexBytes(bytes: number[]): string;
        function patchHex(bin: Binary, buf: number[], shortForm: boolean, useuf2: boolean): string[];
    }
    function hexDump(bytes: ArrayLike<number>, startOffset?: number): string;
    function asmline(s: string): string;
    function firstMethodOffset(): number;
    const vtLookups = 3;
    function computeHashMultiplier(nums: number[]): {
        mult: number;
        mapping: Uint16Array;
        size: number;
    };
    function vtableToAsm(info: ClassInfo, opts: CompileOptions, bin: Binary, res: CompileResult): string;
    function processorInlineAssemble(target: CompileTarget, src: string): number[];
    function assemble(target: CompileTarget, bin: Binary, src: string, cres: CompileResult): {
        src: string;
        buf: number[];
        thumbFile: assembler.File;
    };
    function processorEmit(bin: Binary, opts: CompileOptions, cres: CompileResult): void;
    let validateShim: typeof hexfile.validateShim;
}
declare namespace ts.pxtc {
    function getHelpForKeyword(word: string, isPython: boolean): string;
}
declare namespace ts.pxtc {
    class LSHost implements ts.LanguageServiceHost {
        private p;
        constructor(p: ts.Program);
        getCompilationSettings(): ts.CompilerOptions;
        getNewLine(): string;
        getScriptFileNames(): string[];
        getScriptVersion(fileName: string): string;
        getScriptSnapshot(fileName: string): ts.IScriptSnapshot;
        getCurrentDirectory(): string;
        getDefaultLibFileName(options: ts.CompilerOptions): string;
        useCaseSensitiveFileNames(): boolean;
    }
}
declare namespace ts.pxtc.service {
    function getCallSymbol(callExp: CallExpression): SymbolInfo;
    function getParameter(callSym: SymbolInfo, paramIdx: number, blocksInfo: BlocksInfo): ParameterDesc | undefined;
    function getApisForTsType(pxtType: string, location: Node, tc: TypeChecker, symbols: CompletionSymbol[], isEnum?: boolean): CompletionSymbol[];
    function getBasicKindDefault(kind: SyntaxKind, isPython: boolean): string | undefined;
    function tsSymbolToPxtSymbolKind(ts: ts.Symbol): SymbolKind;
    function makePxtSymbolFromKeyword(keyword: string): SymbolInfo;
    function makePxtSymbolFromTsSymbol(tsSym: ts.Symbol, tsType: ts.Type): SymbolInfo;
    function getPxtSymbolFromTsSymbol(tsSym: ts.Symbol, apiInfo: ApisInfo, tc: TypeChecker): SymbolInfo | undefined;
    function compareCompletionSymbols(a: CompletionSymbol, b: CompletionSymbol): number;
    function completionSymbol(symbol: SymbolInfo, weight: number): CompletionSymbol;
    function completionSymbols(symbols: SymbolInfo[], weight: number): CompletionSymbol[];
    function getNodeAndSymbolAtLocation(program: Program, filename: string, position: number, apiInfo: ApisInfo): [Node, SymbolInfo];
    function tsTypeToPxtTypeString(t: Type, tc: TypeChecker): string;
    function filenameWithExtension(filename: string, extension: string): string;
    /**
     * This function only cares about getting words of the form [a-zA-z]+
     */
    function getWordAtPosition(text: string, position: number): {
        text: string;
        start: number;
        end: number;
    };
    function getTsSymbolFromPxtSymbol(pxtSym: SymbolInfo, location: ts.Node, meaning: SymbolFlags): ts.Symbol | null;
    function getDefaultEnumValue(t: Type, python: boolean): string;
    function getCompletions(v: OpArg): CompletionInfo;
}
declare namespace ts.pxtc {
    function getDiagnosticString(diagnostic: KsDiagnostic | Diagnostic): string;
    function plainTscCompileDir(dir: string): Program;
    function plainTscCompileFiles(fileNames: string[], compilerOpts: ts.CompilerOptions): Program;
    function getProgramDiagnostics(program: ts.Program): Diagnostic[];
}
declare namespace ts.pxtc {
    const placeholderChar = "\u25CA";
    interface FunOverride {
        n: string;
        t: any;
        scale?: number;
        snippet?: string;
    }
    const ts2PyFunNameMap: pxt.Map<FunOverride>;
    function emitPyTypeFromTypeNode(s: ts.TypeNode): string;
    function emitPyTypeFromTsType(s: ts.Type): string;
    interface GenDocsOptions {
        package?: boolean;
        locs?: boolean;
        docs?: boolean;
        pxtsnippet?: pxt.SnippetConfig[];
    }
    function genDocs(pkg: string, apiInfo: ApisInfo, options?: GenDocsOptions): pxt.Map<string>;
    function hasBlock(sym: SymbolInfo): boolean;
    function compareSymbols(l: SymbolInfo, r: SymbolInfo): number;
    function getApiInfo(program: Program, jres?: pxt.Map<pxt.JRes>, legacyOnly?: boolean): ApisInfo;
    function internalGetApiInfo(program: Program, jres?: pxt.Map<pxt.JRes>, legacyOnly?: boolean): {
        apis: ApisInfo;
        decls: pxt.Map<Declaration>;
    };
    function getFullName(typechecker: TypeChecker, symbol: Symbol): string;
}
declare namespace ts.pxtc.service {
    class Host implements LanguageServiceHost {
        opts: CompileOptions;
        fileVersions: pxt.Map<number>;
        projectVer: number;
        pxtModulesOK: string;
        getProjectVersion(): string;
        setFile(fn: string, cont: string): void;
        reset(): void;
        setOpts(o: CompileOptions): void;
        getCompilationSettings(): CompilerOptions;
        getScriptFileNames(): string[];
        getScriptVersion(fileName: string): string;
        getScriptSnapshot(fileName: string): IScriptSnapshot;
        getNewLine(): string;
        getCurrentDirectory(): string;
        getDefaultLibFileName(options: CompilerOptions): string;
        log(s: string): void;
        trace(s: string): void;
        error(s: string): void;
        useCaseSensitiveFileNames(): boolean;
    }
    interface CachedApisInfo {
        apis: ApisInfo;
        decls: pxt.Map<Declaration>;
    }
    export interface CompletionSymbol {
        symbol: SymbolInfo;
        weight: number;
    }
    export let service: LanguageService;
    export let host: Host;
    export let lastApiInfo: CachedApisInfo | undefined;
    export let lastGlobalNames: pxt.Map<SymbolInfo> | undefined;
    export let lastBlocksInfo: BlocksInfo;
    export let lastLocBlocksInfo: BlocksInfo;
    export let builtinItems: SearchInfo[];
    export let blockDefinitions: pxt.Map<pxt.blocks.BlockDefinition>;
    export let tbSubset: pxt.Map<boolean | string>;
    export function blocksInfoOp(apisInfoLocOverride: pxtc.ApisInfo, bannedCategories: string[]): BlocksInfo;
    export function getLastApiInfo(opts: CompileOptions): CachedApisInfo;
    export function addApiInfo(opts: CompileOptions): void;
    export function cloneCompileOpts(opts: CompileOptions): CompileOptions;
    export interface ServiceOps {
        reset: () => void;
        setOptions: (v: OpArg) => void;
        syntaxInfo: (v: OpArg) => SyntaxInfo;
        getCompletions: (v: OpArg) => CompletionInfo;
        compile: (v: OpArg) => CompileResult;
        decompile: (v: OpArg) => CompileResult;
        pydecompile: (v: OpArg) => transpile.TranspileResult;
        decompileSnippets: (v: OpArg) => string[];
        assemble: (v: OpArg) => {
            words: number[];
        };
        py2ts: (v: OpArg) => transpile.TranspileResult;
        fileDiags: (v: OpArg) => KsDiagnostic[];
        allDiags: () => CompileResult;
        format: (v: OpArg) => {
            formatted: string;
            pos: number;
        };
        apiInfo: () => ApisInfo;
        snippet: (v: OpArg) => string;
        blocksInfo: (v: OpArg) => BlocksInfo;
        apiSearch: (v: OpArg) => SearchInfo[];
        projectSearch: (v: OpArg) => ProjectSearchInfo[];
        projectSearchClear: () => void;
    }
    export type OpRes = string | void | SyntaxInfo | CompletionInfo | CompileResult | transpile.TranspileResult | {
        words: number[];
    } | KsDiagnostic[] | {
        formatted: string;
        pos: number;
    } | ApisInfo | BlocksInfo | ProjectSearchInfo[] | {};
    export type OpError = {
        errorMessage: string;
    };
    export type OpResOrError = OpRes | OpError;
    export function IsOpErr(res: OpResOrError): res is OpError;
    export function runConversionsAndCompileUsingService(): CompileResult;
    export function performOperation<T extends keyof ServiceOps>(op: T, arg: OpArg): OpResOrError;
    export {};
}
declare namespace ts.pxtc.service {
    type SnippetNode = SnippetReplacePoint | string | SnippetNode[];
    interface SnippetReplacePoint {
        default: SnippetNode;
        isLiteral?: boolean;
        isDefinition?: boolean;
    }
    function snippetStringify(snippet: SnippetNode, emitMonacoReplacementPoints?: boolean): string;
    function snippetHasReplacementPoints(snippet: SnippetNode): boolean;
    function snippetAddsDefinitions(snippet: SnippetNode): boolean;
    interface SnippetContext {
        apis: ApisInfo;
        blocksInfo: BlocksInfo;
        takenNames: pxt.Map<SymbolInfo>;
        checker: ts.TypeChecker;
        screenSize?: pxt.Size;
        parameterOverride?: {
            [key: string]: SnippetNode;
        };
        includeParentSnippet?: boolean;
    }
    function getSnippet(context: SnippetContext, fn: SymbolInfo, decl: ts.FunctionLikeDeclaration, python?: boolean, recursionDepth?: number): SnippetNode;
    function isTaggedTemplate(sym: SymbolInfo): boolean;
}
declare namespace ts.pxtc.transpile {
    interface TranspileCodeResult {
        outfiles: pxt.Map<string>;
        sourceMap: SourceInterval[];
        syntaxInfo?: SyntaxInfo;
        globalNames?: pxt.Map<SymbolInfo>;
    }
    interface TranspileResult extends TranspileCodeResult {
        diagnostics: pxtc.KsDiagnostic[];
        success: boolean;
    }
    function pyToTs(options: pxtc.CompileOptions, filename?: string): TranspileResult;
    function tsToPy(program: ts.Program, filename?: string): TranspileResult;
}
declare namespace ts.pxtc {
    function getParentCallExpression(tsNode: Node): ts.CallExpression | undefined;
    function findCurrentCallArgIdx(call: ts.CallExpression, tsNode: Node, tsPos: number): number;
    enum TraverseCheck {
        Found = 0,
        Continue = 1,
        Abort = 2
    }
    function traverseUp(node: Node, predicate: (n: Node) => TraverseCheck): Node | undefined;
    function enumMemberToQName(tc: TypeChecker, e: EnumMember): string;
    function findInnerMostNodeAtPosition(n: Node, position: number): Node | null;
    function getParentNamespace(n?: Node): ModuleDeclaration | undefined;
    function getCurrentNamespaces(n?: Node): string[];
    function getEnumMembers(checker: ts.TypeChecker, t: Type): NodeArray<EnumMember> | undefined;
    function isExported(decl: Declaration): boolean;
    function isReadonly(decl: Declaration): boolean;
}
declare namespace ts.pxtc.vm {
    class VmInstruction extends assembler.Instruction {
        constructor(ei: assembler.AbstractProcessor, format: string, opcode: number);
        emit(ln: assembler.Line): assembler.EmitResult;
    }
    const withPush: pxt.Map<boolean>;
    const opcodes: string[];
    class VmProcessor extends pxtc.assembler.AbstractProcessor {
        constructor(target: CompileTarget);
        testAssembler(): void;
        postProcessRelAddress(f: assembler.File, v: number): number;
        postProcessAbsAddress(f: assembler.File, v: number): number;
        getAddressFromLabel(f: assembler.File, i: assembler.Instruction, s: string, wordAligned?: boolean): number;
        toFnPtr(v: number, baseOff: number): number;
        wordSize(): number;
        peephole(ln: assembler.Line, lnNext: assembler.Line, lnNext2: assembler.Line): void;
    }
}
